/**
 * Copyright 2003-2008 非也
 * All rights reserved. 
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation。
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses. *
 * @author 非也,nychen2000@163.com
 * @Revision to .NET 无忧 lwz0721@gmail.com 2010-02
 */
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using FireWorkflow.Net.Engine;
using FireWorkflow.Net.Engine.Definition;
using FireWorkflow.Net.Engine.Event;
using FireWorkflow.Net.Engine.Persistence;
using FireWorkflow.Net.Kernel;
using FireWorkflow.Net.Kernel.Impl;
using FireWorkflow.Net.Model;

namespace FireWorkflow.Net.Engine.Impl
{
    /// <summary>ProcessInstance generated by hbm2java</summary>
    [Serializable]
    public class ProcessInstance : IProcessInstance, IRuntimeContextAware, IWorkflowSessionAware
    {
        public String Id { get; set; }
        public String ProcessId { get; set; }
        public Int32 Version { get; set; }
        public String Name { get; set; }
        public String DisplayName { get; set; }
        public ProcessInstanceEnum State { get; set; }
        public Boolean? Suspended { get; set; }
        public String CreatorId { get; set; }
        public DateTime? CreatedTime { get; set; }
        public DateTime? StartedTime { get; set; }
        public DateTime? EndTime { get; set; }
        public DateTime? ExpiredTime { get; set; }
        public String ParentProcessInstanceId { get; set; }
        public String ParentTaskInstanceId { get; set; }
        private Dictionary<String, Object> _processInstanceVariables;
        public Dictionary<String, Object> ProcessInstanceVariables
        {
            get
            {
                IPersistenceService persistenceService = this.RuntimeContext.PersistenceService;
                if (_processInstanceVariables == null)
                {
                    //通过数据库查询进行初始化
                    List<ProcessInstanceVar> allVars = persistenceService.FindProcessInstanceVariable(this.Id);
                    _processInstanceVariables = new Dictionary<String, Object>();
                    if (allVars != null && allVars.Count != 0)
                    {
                        foreach (ProcessInstanceVar theVar in allVars)
                        {
                            _processInstanceVariables.Add(theVar.VarPrimaryKey.Name, theVar.Value);

                        }
                    }
                }
                return _processInstanceVariables;
            }
            set
            {
                _processInstanceVariables = value;
            }
        }

        public RuntimeContext RuntimeContext { get; set; }

        public IWorkflowSession CurrentWorkflowSession { get; set; }

        public ProcessInstance()
        {
            this.State = ProcessInstanceEnum.INITIALIZED;
            this.Suspended = false;
            //this.ProcessInstanceVariables = new Dictionary<String, Object>();
        }

        /// <summary>生成joinPoint</summary>
        /// <param name="synchInst"></param>
        /// <param name="token"></param>
        /// <returns></returns>
        public IJoinPoint createJoinPoint(ISynchronizerInstance synchInst, IToken token)// throws EngineException 
        {

            int enterTransInstanceCount = synchInst.EnteringTransitionInstances.Count;
            if (enterTransInstanceCount == 0)//检查流程定义是否合法，同步器节点必须有输入边
            {
                throw new EngineException(this.Id, this.WorkflowProcess,
                        synchInst.Synchronizer.Id, "The process definition [" + this.Name + "] is invalid，the synchronizer[" + synchInst.Synchronizer + "] has no entering transition");
            }
            IPersistenceService persistenceService = this.RuntimeContext.PersistenceService;
            //保存到数据库
            persistenceService.SaveOrUpdateToken(token);

            IJoinPoint resultJoinPoint = null;
            resultJoinPoint = new JoinPoint();
            resultJoinPoint.ProcessInstance=this;
            resultJoinPoint.SynchronizerId=synchInst.Synchronizer.Id;
            if (enterTransInstanceCount == 1)
            {
                // 生成一个不存储到数据库中的JoinPoint
                resultJoinPoint.addValue(token.Value);

                if (token.IsAlive)
                {
                    resultJoinPoint.Alive=true;
                    resultJoinPoint.FromActivityId=token.FromActivityId;
                }
                resultJoinPoint.StepNumber=token.StepNumber + 1;

                return resultJoinPoint;
            }
            else
            {
                int stepNumber = 0;

                List<IToken> tokensList_0 = persistenceService.FindTokensForProcessInstance(this.Id, synchInst.Synchronizer.Id);
                Dictionary<String, IToken> tokensMap = new Dictionary<String, IToken>();
                for (int i = 0; i < tokensList_0.Count; i++)
                {
                    IToken tmpToken = (IToken)tokensList_0[i];
                    String tmpFromActivityId = tmpToken.FromActivityId;
                    if (!tokensMap.ContainsKey(tmpFromActivityId))
                    {
                        tokensMap.Add(tmpFromActivityId, tmpToken);
                    }
                    else
                    {
                        //TODO  ====下面的代码有意义吗？===start===wmj2003
                        IToken tmpToken2 = (IToken)tokensMap[tmpFromActivityId];
                        if (tmpToken2.StepNumber > tmpToken.StepNumber)
                        {
                            tokensMap[tmpFromActivityId] = tmpToken2;
                        }
                        //TODO  ====下面的代码有意义吗？===end===wmj2003
                    }
                }

                List<IToken> tokensList = new List<IToken>(tokensMap.Values);

                for (int i = 0; i < tokensList.Count; i++)
                {
                    IToken _token = (IToken)tokensList[i];
                    resultJoinPoint.addValue(_token.Value);
                    if (_token.IsAlive)//如果token的状态是alive
                    {
                        resultJoinPoint.Alive=true;
                        String oldFromActivityId = resultJoinPoint.FromActivityId;
                        if (String.IsNullOrEmpty(oldFromActivityId))
                        {
                            resultJoinPoint.FromActivityId=_token.FromActivityId;
                        }
                        else
                        {
                            resultJoinPoint.FromActivityId=oldFromActivityId + TokenFrom.FROM_ACTIVITY_ID_SEPARATOR + _token.FromActivityId;
                        }
                    }
                    if (token.StepNumber > stepNumber)
                    {
                        stepNumber = token.StepNumber;
                    }
                }

                resultJoinPoint.StepNumber=stepNumber + 1;

                return resultJoinPoint;
            }
        }

        public void run()
        {
            if (this.State != ProcessInstanceEnum.INITIALIZED)
            {
                throw new EngineException(this.Id,
                        this.WorkflowProcess,
                        this.ProcessId, "The state of the process instance is " + this.State + ",can not run it ");
            }

            INetInstance netInstance = (INetInstance)this.RuntimeContext.KernelManager.getNetInstance(this.ProcessId, this.Version);
            if (netInstance == null)
            {
                throw new EngineException(this.Id,
                        this.WorkflowProcess,
                        this.ProcessId, "The net instance for the  workflow process [Id=" + this.ProcessId + "] is Not found");
            }
            //触发事件
            ProcessInstanceEvent pevent = new ProcessInstanceEvent();
            pevent.EventType = ProcessInstanceEventEnum.BEFORE_PROCESS_INSTANCE_RUN;
            pevent.Source=this;
            this.fireProcessInstanceEvent(pevent);

            this.State=ProcessInstanceEnum.RUNNING;
            this.StartedTime=this.RuntimeContext.CalendarService.getSysDate();
            this.RuntimeContext.PersistenceService.SaveOrUpdateProcessInstance(this);
            netInstance.run(this);
        }


        public Object getProcessInstanceVariable(String name)
        {
            if (_processInstanceVariables == null)
            {
                //通过数据库查询进行初始化
                IPersistenceService persistenceService = this.RuntimeContext.PersistenceService;
                List<ProcessInstanceVar> allVars = persistenceService.FindProcessInstanceVariable(this.Id);
                _processInstanceVariables = new Dictionary<String, Object>();
                if (allVars != null && allVars.Count != 0)
                {
                    foreach (ProcessInstanceVar theVar in allVars)
                    {
                        _processInstanceVariables.Add(theVar.VarPrimaryKey.Name, theVar.Value);
                    }
                }
            }
            return _processInstanceVariables[name];
        }

        public void setProcessInstanceVariable(String name, Object value)
        {
            IPersistenceService persistenceService = this.RuntimeContext.PersistenceService;
            if (_processInstanceVariables == null)
            {
                //通过数据库查询进行初始化
                List<ProcessInstanceVar> allVars = persistenceService.FindProcessInstanceVariable(this.Id);
                _processInstanceVariables = new Dictionary<String, Object>();
                if (allVars != null && allVars.Count != 0)
                {
                    foreach (ProcessInstanceVar theVar in allVars)
                    {
                        _processInstanceVariables.Add(theVar.VarPrimaryKey.Name, theVar.Value);
                    }
                }
            }
            ProcessInstanceVar procInstVar = new ProcessInstanceVar();
            ProcessInstanceVarPk pk = new ProcessInstanceVarPk();
            pk.ProcessInstanceId=this.Id;
            pk.Name=name;
            procInstVar.VarPrimaryKey=pk;
            procInstVar.Value = value.ToString();
            procInstVar.ValueType=value.GetType().Name;
            
            if (_processInstanceVariables.ContainsKey(name))
            {
                persistenceService.UpdateProcessInstanceVariable(procInstVar);
                _processInstanceVariables[name] = value;
            }
            else
            {
                persistenceService.SaveProcessInstanceVariable(procInstVar);
                _processInstanceVariables.Add(name, value);
            }
        }

        public WorkflowProcess WorkflowProcess
        {
            get
            {
                WorkflowDefinition workflowDef = this.RuntimeContext.DefinitionService.GetWorkflowDefinitionByProcessIdAndVersionNumber(this.ProcessId, this.Version);
                
                WorkflowProcess workflowProcess = null;
                workflowProcess = workflowDef.getWorkflowProcess();
                return workflowProcess;
            }
        }


        public String WorkflowProcessId
        {
            get
            {
                return WorkflowProcess.Sn;
            }
        }

        /// <summary>
        /// <para>正常结束工作流</para>
        /// <para>1、首先检查有无活动的token,如果有则直接返回，如果没有则结束当前流程</para>
        /// <para>2、执行结束流程的操作，将state的值设置为结束状态</para>
        /// 3、然后检查parentTaskInstanceId是否为null，如果不为null则，调用父taskinstance的complete操作。
        /// </summary>
        public void complete()
        {
            List<IToken> tokens = this.RuntimeContext.PersistenceService.FindTokensForProcessInstance(this.Id, null);
            Boolean canBeCompleted = true;
            for (int i = 0; tokens != null && i < tokens.Count; i++)
            {
                IToken token = tokens[i];
                if (token.IsAlive)
                {
                    canBeCompleted = false;
                    break;
                }
            }
            if (!canBeCompleted)
            {
                return;
            }

            this.State=ProcessInstanceEnum.COMPLETED;
            //记录结束时间
            this.EndTime=this.RuntimeContext.CalendarService.getSysDate();
            this.RuntimeContext.PersistenceService.SaveOrUpdateProcessInstance(this);

            //删除所有的token
            for (int i = 0; tokens != null && i < tokens.Count; i++)
            {
                IToken token = tokens[i];
                this.RuntimeContext.PersistenceService.DeleteToken(token);
            }

            //触发事件
            ProcessInstanceEvent pevent = new ProcessInstanceEvent();
            pevent.EventType=ProcessInstanceEventEnum.AFTER_PROCESS_INSTANCE_COMPLETE;
            pevent.Source=this;
            this.fireProcessInstanceEvent(pevent);
            if ( !String.IsNullOrEmpty(this.ParentTaskInstanceId.Trim()))
            {
                ITaskInstance taskInstance = this.RuntimeContext.PersistenceService.FindAliveTaskInstanceById(this.ParentTaskInstanceId);
                ((IRuntimeContextAware)taskInstance).RuntimeContext=this.RuntimeContext;
                ((IWorkflowSessionAware)taskInstance).CurrentWorkflowSession = this.CurrentWorkflowSession;
                ((TaskInstance)taskInstance).complete(null);
            }
        }

        public void abort()
        {
            if (this.State == ProcessInstanceEnum.COMPLETED || this.State == ProcessInstanceEnum.CANCELED)
            {
                throw new EngineException(this, this.WorkflowProcess, "The process instance can not be aborted,the state of this process instance is " + this.State);
            }
            IPersistenceService persistenceService = this.RuntimeContext.PersistenceService;
            persistenceService.AbortProcessInstance(this);
        }

        /// <summary>触发process instance相关的事件</summary>
        /// <param name="e"></param>
        protected void fireProcessInstanceEvent(ProcessInstanceEvent e)
        {
            WorkflowProcess workflowProcess = this.WorkflowProcess;
            if (workflowProcess == null)
            {
                return;
            }

            List<EventListener> listeners = workflowProcess.EventListeners;
            for (int i = 0; i < listeners.Count; i++)
            {
                EventListener listener = (EventListener)listeners[i];
                Object obj = this.RuntimeContext.getBeanByName(listener.ClassName);
                if (obj != null)
                {
                    ((IProcessInstanceEventListener)obj).onProcessInstanceEventFired(e);
                }
            }
        }

        public Boolean? IsSuspended()
        {
            return Suspended;
        }

        public void suspend()
        {
            if (this.State == ProcessInstanceEnum.COMPLETED || this.State == ProcessInstanceEnum.CANCELED)
            {
                throw new EngineException(this, this.WorkflowProcess, "The process instance can not be suspended,the state of this process instance is " + this.State);
            }
            if (this.IsSuspended() != null && (bool)this.IsSuspended())
            {
                return;
            }
            IPersistenceService persistenceService = this.RuntimeContext.PersistenceService;
            persistenceService.SuspendProcessInstance(this);
        }

        public void restore()
        {
            if (this.State == ProcessInstanceEnum.COMPLETED || this.State == ProcessInstanceEnum.CANCELED)
            {
                throw new EngineException(this, this.WorkflowProcess, "The process instance can not be restored,the state of this process instance is " + this.State);
            }
            if (!(this.IsSuspended() != null && (bool)this.IsSuspended()))
            {
                return;
            }
            IPersistenceService persistenceService = this.RuntimeContext.PersistenceService;
            persistenceService.RestoreProcessInstance(this);
        }
    }
}
